# 05 소프트웨어에서 표현되는 모델


## 연관관계
> 모델 내의 모든 탐색 가능한 연관관계에 대해 그것과 동일한 특성을 지닌 메커니즘이 소프트웨어에도 있다.

현실세계에는 수많은 다대다 연관관계가 있으며, 애초부터 양방향으로 나타난다. 이러한 일반적인 형태의 연관관계는 구현과 유지보수를 복잡하게만들어, 연관관계를 쉽게 다루도록 노력해야한다.

### 연관관계를 좀 더 쉽게 다루는 방법
- 탐색 방향을 부여한다.
- 한정자를 추가하여 사실상 다중성을 줄인다
- 중요하지 않은 연관관계 제거한다.

도메인을 깊이 있게 이해하다 보면 **한정적인** 관계에 이르게 되는데, 이때 연관관계에 대한 제약조건이 발견되면 해당 제약조건은 모델과 구현에 포함되어야 한다. 그와 같은 제약조건은 모델을 더 정확하게 하고 구현을 더 쉽게 유지보수 할 수 있게 만들어 준다.

### 연관관계를 정의하는 예
"2021년 대한민국의 대통령은 누구인가?"
"관리자가 작성한 글은 어떤것인가?"

-----------

## ENTITY(엔티티, 참조객체)
> 엔티티는 해당 객체의 속성이 아닌 연속성과 식별성이 이어지느냐를 기준으로 정의된다.

### 엔티티의 특징
- record간에 구별이 필요한 객체
- Entity의 근본적인 개념은 객체의 생명주기 내내 이어지는 추상적인 연속성이며, 그러한 추상적인 연속성은 여러 형태를 거쳐 전달된다는 것이다.
- 어떤객체를 일차적으로 해당 객체의 식별성으로 정의할 경우 그 객체를 ENTITY라 한다.
- ENTITY에는 모델링과 설계상의 특수한 고려사항이 포함되어 있다.
- ENTITY는 자신의 생명주기동안 형태와 내용이 급격하게 바뀔 수도 있지만 연속성은 유지되어야 하며, 이를 추적하기위해 식별성이 정의되어 있어야 한다. 
  - ex. 사람, 자동ㅈ차, 도시, 복권 티켓, 은행 거래 등...
  

### 식별성으로 객체를 구분하기위한 방법
- 식별성으로 구분될 경우 모델 내에서 이를 해당 객체의 주된 정의로 삼는다.
- 클래스 정의를 단순하게 하고, 생명주기의 연속성과 식별성에 집중한다.
- 객체의 형태나 이력에 관계없이 각 객체를 구별하는 수단으로 정의한다.
- 객체의 속성으로 객체의 일치 여부를 판단하는 요구사항에 주의한다.
- 각 객체에 대해 유일한 결과를 반환하는 연산을 정의한다.


### 엔티티의 예
- 좌석번호가 있는 좌석
- 비행기 좌석
- 사람(주민등록번호)
- 비디오 대여점의 고객(등록 번호)

-----------

## VALUE OBJECT(값 객체)

### VALUE OBJECT 의 특징
- Entity와는 다르게 구별이 필요없는 객체
- 요소의 속성을 표현하기 위함
- Value object는 불변적으로 다뤄야하며, 식별성도 부여하지 말고 ENTITY를 유지하는데 필요한 설계상 복잡성을 피해야한다.
- Value Object는 참조한 Entity의 정보를 제공할 수 있고, 개념적으로 완전해야 한다.

### VALUE OBJECT의 설계

VALUE OBJECT는 많아지는 경향이 있으므로 **성능 최적화**를 위한 별도의 대안을 마련하는 것이 중요할 수 있다.

> 주택소프트웨어 설계를 위해 각 콘센트를 하나의 인스턴스로 생성하고 공유

#### 공유가 유용한 Value Object 케이스
- 공간을 절약하거나 데이터베이스 내의 객체 수를 줄이는 것이 중요한 경우
- 통신 부하가 낮은 경우(ex. 중앙집중형 서버)
- 공유 객체의 불변성이 엄격하게 지켜지는 경우 

#### 특별히 VALUE OBJECT의 변경가능성을 허용하는 경우
- Value가 자주 변경되는 경우
- 객체 생성이나 삭제에 비용이 큰 경우
- 교체로 인해(변경이 아닌) 클러스터링이 제한되는 경우
- Value를 공유할 일이 그리 많지 않거나 클러스터링을 향상시키기 위해서나 다른 기술적인 이유로 공유가 보류된 경우

**VALUE의 구현이 변경가능하다면 그것을 공유하면 안 된다. VALUE의 공유 여부와는 관계없이 VALUE OBJECT는 가급적 변하지 않게 설계하자.**

### VALUE OBJECT를 포함한 연관관계 설계
- VALUE OBJECT는 식별성이 없는 객체이므로, VALUE OBJECT간의 연관관계는 의미없는 관계인 것이다. 때문에, VALUE OBJECT 간 양방향 연관관계는 완전히 제거하도록 노력해야 한다.

-----------

## SERVICE (서비스)
> 개념적으로 어떠한 객체에도 속하지 않는 연산이 포함될 때가 있다. 이러한 문제를 억지로 해결하려 하기보다는 문제 자체의 면면에 따라 SERVICE를 모델에 명시적으로 포함하여 해결할 수 있다.

### SERVICE의 특징
- 서비스라는 이름은 다른 객체와의 관계를 강조한다.
- 연산이 Entity나 Value Object의 일부를 구성하는 것이 아니라 도메인 개념과 관련돼 있다.
- 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다.
- 서비스는 대부분의 도메인 객체와 달리 자신의 행위에 영향을 줄 수 있는 상태를 갖지 않는다.

 
### 서비스와 격리된 도메인 계층
서비스 또한 Layerd Architecture에 따라 구분해야 한다. 각 계층에 따라 갖는 책임이 다를 것이고 이를 명확하게 구분할 수 있도록 설계하는데 주의를 기울일 필요가 있다.

- 응용 계층	
  - 자금 이체 응용 서비스
    - 관련 개인정보의 암복호화
    - 이체 처리를 위한 도메인 서비스로 메시지 전송
    - 이체 확인 대기
    - 인프라스트럭처 서비스를 이용한 통지
- 도메인 계층	
  - 자금 이체 도메인 서비스
    - 금액 인출/입금에 필요한 계좌-거래내역 객체 간의 상호작용
    - 이체 결과 확인 정보 제공
- 인프라스트럭처 계층 	
  - 통지 서비스
    - 애플리케이션에서 지정한 곳으로 이메일, 우편 등 발송 

### 구성단위
이 패턴은 ENTITY와 VALUE OBJECT로부터 클라이언트를 분리하는 것과 함께 도메인 계층의 인터페이스 구성 단위를 제어하는 수단으로써도 가치가 있다. 또한 단순한 인터페이스 너무에 중요한 기능을 캡슐화하고 있기 때문에 대형 시스템에서 재사용하기가 좀 더 용이하다.

-----------

## MODULE(모듈, 패키지라고도 함)

### 모듈화를 하는 주된 이유
- 인지적과부하를 방지하여, 전체에 압도되지 않고도 MODULE에 들어있는 세부사항들을 보거나, 세부사항을 배제한 상태에서 MODULE간의 관계를 볼수 있기 위함이다.
- MODULE간에는 결합도가 낮아야 하고, MODULE의 내부는 응집도가 높아야 한다.
- 어떤 사람이 한 번에 생각해낼 수 있는 양에는 한계가 있으며(결합도 낮춰야), 일관성이 없는 단편적인 생각은 획일적인 생각을 썪어놓은 것처럼 이해하기 어렵다(응집도 높여야).

시스템의 내력을 말해주는 Module을 골라 일련의 응집력 있는 개념들을 해당 Module에 담아라. 이렇게 하면 종종 모듈 간의 결합도가 낮아지기도 하는데, 그렇게 되지 않는다면 모델을 변경해서 얽혀 있는 개념을 풀어낼 방법을 찾아보거나, 아니면 의미 있는 방식으로 모델의 각 요소를 맺어줄, Module의 기줄이 될 법한 것 중 미처 못보고 지나친 개념을 찾아보라. 서로 독립적으로 이해하고 논리적으로 추론할 수 있다는 의미에서 낮은 결합도가 달성되도록 노력하라. 높은 수준의 도메인 개념에 따라 모델이 분리되고 그것에 대응되는 코드도 분리될 때까지 모델을 정제하라.

Ubiquitous Language를 구성하는 것으로 Module의 이름을 부여하라. Module과 Module의 이름은 도메인에 통찰력을 줄 수 있어야 한다.

### 모듈 설계시 주의사항
모듈을 변경하기 위해서는 넓은 범위에 걸친 코드를 수정해야함 한다. 이 같은 변경은 팀의 의사소통을 해치고 여러 문제를 야기시킬수 있어, 모듈 리펙토링은 가급적 최소화해야하고, 설계에서 부터 잘 될수 있도록 노력해야한다.


### 모델링 페러다임

#### 객체지향 패러다임이 지배적인 이유는,
- 인간에게 직관적인 개념을 바탕으로 쉽게 접근
- 복잡함과 단숨함의 조화
- 개발자 커뮤니티와 설계문화 자체의 성숙도

#### 객체가 아닌 요소를 객체지향 시스템에 혼합하는 법칙
- 구현 패러다임을 도메인에 억지로 맞추지 않는다.
- 유비쿼터스 언어에 의지한다.
- UML에 심취하지 않는다
- 회의적이어야한다.



## 참고자료
- [DDD 핵심만 빠르게 이해하기](https://happycloud-lee.tistory.com/94)
